[5905. 到达目的地的第二短时间](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/)

<h2>思路分析</h2>
首先意识到一个问题，如果路径A的长度小于路径B的长度，那么路径A的时间一定小于路径B的时间，即，给定time和change之后，总时间是一个只与路径长度有关的递增函数。

因此，总共需要两步：第一步是求出倒数第二短的路径长度，第二步是求出该路径所需时间。

第一步：很明显，倒数第一短的路径长度可以直接用BFS取得，倒数第二短的路径长度也可以用BFS取得，但是需要剪枝，否则遇到环路就无限循环直接GG了。

具体的操作为：BFS的队列中存储节点+到达该节点的路径长度，另外新开一个数组，记录每个节点的最短路径和次短路径，BFS每次访问一个节点时，不要把这个节点的所有孩子都加入到队列中，而是计算一下到达该节点的孩子的路径长度（到达该节点的路径长度加1），如果该长度是比最短路径和次短路径都长的，那么就没有访问的必要了，不要加入队列，否则，更新一下最短路径和次短路径，并加入队列即可。

第二步：求出该路径所需时间。这一步就不需要任何算法了，直接模拟整个过程即可：如果到某个节点时为绿灯，那么直接前往下一个节点，否则，等到绿灯之后再前往下一个节点。

感觉主要的难点在于用剪枝的BFS来计算次短路径的长度，算是BFS的一个灵活应用。